/*F.Hecht, G.Lance, E. TrÃ©lat
Reusable template to solve optimization problem using IpOpt within FreeFEM
Example taken from "PDE constrained optimization within FreeFEM"
Example (2.1,2.2,2.3) in Section 2.1:
Solving template for LQ example 
\min_{u} \frac{1}{2}\int_{\Omega} (y-y_d)^2\,dx + \frac{}\alpha}{2} \int_{\Omega} u^2 \,dx
under the constraints
-\Delta y = u, y_{\vert \partial \Omega} = 0
Option 2 : direct mode with U as unknowns
*/

load "ff-Ipopt";
verbosity = 0;

// square mesh
mesh Th = square(100,100); // square mesh with boundary labels 1,2,3,4

fespace Vh(Th,P1); // finite element space with $P_1$ elements
int nbs = Vh.ndof; // number of degrees of freedom

Vh yh,vh;
Vh ydfe = 1.0; // target
real[int] yd = ydfe[];

// Bounds on control u_m \leq u \leq u_M
real um = -10000;
real uM = 10000;

real alpha = 1.0;

// Variational formulations
macro grad(yh) [dx(yh), dy(yh)] //

varf vA(yh,vh) = int2d(Th)(grad(yh)'*grad(vh))
			 + on(1,2,3,4,yh=0); // Dirichlet Laplacian
varf vB(yh,vh) = int2d(Th)(yh*vh);

matrix A = vA(Vh,Vh,solver=sparsesolver); // stiffness matrix
matrix M = vB(Vh,Vh,solver=sparsesolver); // mass matrix


func real J(real[int] &X)
{
	real cost;
	
	// Solve state equation
	real[int] Uint = M*X;
	real[int] Y = A^-1*Uint;
	
	// L2 cost for target function
	real[int] U = Y-yd;
	real[int] Yint = M*U;
	cost = U'*Yint;
	
	// L2 cost for control
	cost+= Uint'*X*alpha;
	cost = 0.5*cost;
	return cost;
}

func real[int] gradJ(real[int] &X)
{	
	// Solve state equation
	real[int] Uint = M*X;
	real[int] Y = A^-1*Uint;
	real[int] U = yd-Y;
	
	// Solve adjoint equation
	Uint = M*U;
	real[int] p = A^-1*Uint;	
	
	// Compute gradient for L2 scalar product
	U = -p + alpha*X; 
	p = M*U;
	return p;
}


// Variable bounds + initialisation
real[int] xub(nbs);
real[int] xlb(nbs);
real[int] start(nbs);
xub = uM;
xlb = um;

//hotrestart routine
int hotrestart=1;

if (hotrestart==1){
	Vh X0;
	mesh Th00 = readmesh("Th0old.msh"); // Initial mesh
	fespace Vh0(Th00,P1); 
	Vh0 X00;
	{
		ifstream file("fsol.txt"); file >> X00[];
	}
	X0 = X00; // interpolation on the new mesh return Xinit[];
	start = X0[];
}

// Launch Ipopt
IPOPT(J,gradJ,start,optfile="ipopt.opt");

vh[] = start;
plot(Th,vh,fill=1,value=1,wait=1);

// hotrestart
// first create a solution (hotrestart deactivated)
if (hotrestart == 0){ 
	savemesh(Th,"Th0old.msh"); 
	{
		ofstream file("fsol.txt"); 
		file << vh[];
	}
}
